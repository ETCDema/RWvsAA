# Form model

Итак, мы определились с тем, что именно FormModel отправляется в шаблон для генерации HTML и потом используется для раскладки данных из запроса. Теперь посмотрим что у нас изменилось в схеме [приведенной ранее](#doc:start).

![Form Model](/img/form-model.min.svg)

FormModel мы связываем с моделью данных и передаем в шаблон для генерации HTML, при этом у нас одна FormModel на все наши модели данных и основной шаблон нам нужен один. Далее для каждого типа свойства мы создадим свои шаблоны, в самом начале нам точно потребуются шаблоны ввода/отображения текста, числа, даты и Enum, потом добавятся еще узкоспециализированные шаблоны какой-либо сложной структуры, например для ввода/отображения адреса или кодов аналитики.

Логично предположить что в эти вложенные шаблоны саму FormModel мы передавать не будем, но нам нужен аналог уже для отдельного свойства модели данных и назовем эту сущность Element. По сути это тоже FromModel, но самостоятельно существовать не может и отвечает за конкретное свойство модели данных.

При раскладке данных нам нужен источник этих самых данных и можно совершенно спокойно использовать например стандартную IFromCollection, которую мы передаем в FormModel а внутри уже передается в Element для обработки конкретных значений.

FormModel и Element будут у нас контейнерами информации для генерации HTML, раскладки и валидации данных, по сути заменят нам ModelMetadata и может показаться, что мы будем строить God-like объекты, но это не так. Эти объекты будут построены на очень простом, но, как показала практика, очень эффективном подходе.

## Основа для FormModel и Element

На идею этого подхода натолкнули 2 вещи:
1. Статья про разработку игры, где вместо наследования использовалось агрегация
1. Организация контекста в OWIN

Там по сути была описана работа с некими `IDictionary<TKey, object>`, где в качестве TKey выступает либо некий числовой идентификатор либо строка. Однако работа с таким типом ключей подвержена проблемам:
1. Реестр возможных (допустимых) ключей нужно где-то вести, иначе будут проблемы с хардкодом значений ключей во всему коду и собрать целостную картину для исключения коллизий будет проблематично, но реестр тоже может не спасти от лени разработчиков
1. Из-за полной свободы с ключами невозможно эффективно проводить рефакторинг
1. При получении значений необходимо проводить проверки наличия значения, проверять тип значения а потом приводить значение к нужному типу.

Т.е. типичный код выглядит так:
```csharp
// Установим значение
dic.Set(Codes.SomeCode1, new TValue(...));

// Получим значение ожидаемого типа
if (dic.TryGet(Codes.SomeCode1, out var data) && data is TValue typedData)
{
    // TODO: Данные есть
} else
{
    // TODO: Данных нет или они не того типа
}
```
Громоздко и ненадежно. 

Но если в качестве ключа использовать тип значения т.е. должно соблюдаться условие `TValue is TKey == true` то все становится проще:
```csharp
// Установим значение
dic.Set<TValue>(new TValue(...));

// Получим значение ожидаемого типа
var typedData = dic.TryGet<TValue>();
```

При этом реализация и сигнатура методов Set/TryGet проста и надежна, для удобства и сохранения концепций .NET сделаем 2 основных интерфейса:
```csharp
public interface IReadOnlyTypedContainer
{
	/// <summary>
	/// Получить значение указанного типа, если нет значения - вернуть nodata.
	/// </summary>
    TData TryGet<TData>(TData nodata = default);
}

public interface ITypedContainer : IReadOnlyTypedContainer
{
	/// <summary>
	/// Установить значение указанного типа, если передать null, то значение будет удалено
	/// </summary>
    void Set<TData>(TData data);
}
```
Все, это - основа.

## Классы FormModel и Element

Реализацию начнем с контроллера, где определим как же мы хотим работать с нашей моделью формы:
```csharp
/// <summary>
/// Отображение данных
/// </summary>
public IActionResult Default()
{
	var frm    = new FormModel /*TODO: Настройка модели формы*/;

	frm.Model  = _getData();    // Получаем данные для отображения и передаем в модель отображения

	return View(frm);           // Все, далее только генерация HTML шаблонами
}
```
В случае изменения данных код немного усложняется:
```csharp
/// <summary>
/// Отображение и изменение данных
/// </summary>
/// <param name="data">Данные запроса</param>
public IActionResult Default(IFormCollection data)
{
	var frm    = new FormModel /*TODO: Настройка модели формы*/;

	frm.Model  = _getData();    // Получаем данные для отображения и передаем в модель отображения
	if (frm.Bind(data))         // Раскладка и проверка данных из запроса
	{
		// TODO: Bind Ok, данные из запроса разложены в модель данных
	}

	return View(frm);           // Все, далее только генерация HTML шаблонами
}
```
В итоге нам в классе модели формы нужно два свойства и один метод:
* Model - непосредственно модель данных, с которой работаем
* Elements - коллекция элементов
* Метод Bind, в котором будет происходить процесс раскладки и проверки данных. 

Пока все выглядит просто. Может вся сложность будет в классе элемента модели формы? Давайте посмотрим что нам нужно там:
* ID - идентификатор элемента для генерации результата и раскладки данных из запроса
* Name - отображаемое имя элемента, требуется на многих этапах для создания сообщений пользователям
* GetFx - функция для получения значения из модели данных
* UIHint - имя шаблона, если он отличен от типа значения, возвращаемого GetFx
* Признак ReadOnly, который будет запрещать раскладку данных и блокировать генерацию полей ввода в шаблоне
* Настройка отображения элемента в рамках модели формы
* Возможно потребуются данные для шаблона
* Настройка генерации JSON
* SetFx - функция для изменения значения модели данных по данным из запроса
* Validate - функция проверки значения из запроса перед или после вызова SetFx
* Error - проблема с элементом

Вот тут набор уже большой, но мы сделаем наш элемент через ITypedContainer, а для этого определим минимум необходимого в самом элементе и какие части будем помещать в ITypedContainer часть. Что точно нужно везде и имеет смысл создать в самом классе Element - свойства ID, Name, GetFx, ReadOnly и, возможно, Error. Остальное разбивается на 2 большие части: данные для отображения (UIHint, настройки элемента и данные для шаблона) и данные для раскладки и проверки значений из запроса (SetFx, Validate). Особняком стоит настройка генерации JSON, но это дополнительная тема и пока ее можно пропустить.

Так как же в итоге будет выглядеть настройка модели формы?

Есть несколько вариантов реализации, самый простой - сделать метод `Add(Element)` у FromModel и далее создавать элемент и добавлять его в контейнер, но для меня более интересна Fluent запись инициализации, в итоге настройка выглядит что примерно так:
```csharp
var frm = new FormModel<TestData>()                                                 // Создаем типизированный контейнер
			.Create("prop1", "String prop", m => m.Prop1,	(m, v) => m.Prop1 = v)  // Создаем и добавляем элемент с отображением и изменением
				.SetRender("String")                                                // Настраиваем шаблон генерации HTML
			.End()                                                                  // Закончим с этим элементом и вернемся к контейнеру
			.Create("num1", "Int prop",		m => m.Num1,	(m, v) => m.Num1 = v)
				.SetRender("Number")
				.Required()                                                         // Добавим валидатор обязательности для этого элемента
			.End()
			.Create("num2", "Decimal prop", m => m.Num2,	(m, v) => m.Num2 = v)
				.SetRender("Number")
				.Required()
			.End()
			.Create("date1", "Date&time",	m => m.Date1,	(m, v) => m.Date1 = v)
				.Set(DataTypes.DateTime)                                            // Тут говорим, что нам нужна дата и время
				.SetRender("DateTime")
				.Required()
			.End();
```
Для того, что бы оставить код классов FormModel и Element максимально простым дополнительные методы сделаем через расширения, собственно сам код можно увидеть в репозитории: [FormModel](#-), [Element](#-) и [ElementExt](#-).

Совершенно необязательно использовать именно такую инициализацию, можно сделать свои методы расширения, которые, например, будут анализировать атрибуты модели данных и создавать необходимые элементы и инициализировать их по данным из атрибутов. Главное - мы получим ту же структуру с такими же свойствами и можем даже проанализировать и перенастроить ее, т.е. можем создать еще один этап конвейера:
- Первоначальное создание структуры, например в фабрике
- Перенастройка, например исходя из прав пользователя
- Использование

При этом каким именно образом создана структура изначально нам совершенно безразлично.

Если внимательно посмотреть на структуру, то можно увидеть, что удаление или перестановка элементов местами тут не предусмотрена и так сделано специально. Элементы можно отключать без необходимости удалять их из коллекции, за порядок отвечает абсолютно самостоятельная часть, которая не требует физической перестановки элементов в коллекции и это все дает нам возможность строить конвейер настройки модели формы с достаточно сложной логикой, когда отдельные этапы знают только о части элементов и не могут убрать ничего лишнего и нужного на других этапах.

Получилось достаточно объемное описание, далее будем подробно разбираться с [генерацией HTML](#-), а потом отдельно с [раскладкой данных из запроса](#-). Ну а дальше разберем более продвинутые темы, например работа формы в связке с VueJS.