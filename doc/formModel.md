# Form model

Итак, мы определились с тем, что именно FormModel отправляется в шаблон для генерации HTML и потом используется для раскладки данных из запроса. Теперь посмотрим что у нас изменилось в схеме [приведенной ранее](#doc:start).

![Form Model](/img/form-model.min.svg)

FormModel мы связываем с моделью данных и передаем в шаблон для генерации HTML, при этом у нас одна FormModel на все наши модели данных и основной шаблон нам нужен один. Далее для каждого типа свойства мы создадим свои шаблоны, в самом начале нам точно потребуются шаблоны ввода/отображения текста, числа, даты и Enum, потом добавятся еще узкоспециализированные шаблоны какой-либо сложной структуры, например для ввода/отображения адреса или кодов аналитики.

Логично предположить что в эти вложенные шаблоны саму FormModel мы передавать не будем, но нам нужен аналог уже для отдельного свойства модели данных и назовем эту сущность Element. По сути это тоже FromModel, но самостоятельно существовать не может и отвечает за конкретное свойство модели данных.

При раскладке данных нам нужен источник этих самых данных и можно совершенно спокойно использовать например стандартную IFromCollection, которую мы передаем в FormModel а внутри уже передается в Element для обработки конкретных значений.

FormModel и Element будут у нас контейнерами информации для генерации HTML, раскладки и валидации данных, по сути заменят нам ModelMetadata и может показаться, что мы будем строить God-like объекты, но это не так. Эти объекты будут построены на очень простом, но, как показала практика, очень эффективном подходе.

## Основа для FormModel и Elements

На идею этого подхода натолкнули 2 вещи:
1. Статья про разработку игры, где вместо наследования использовалось агрегация
1. Организация контекста в OWIN

Там по сути была описана работа с некими `IDictionary<TKey, object>`, где в качестве TKey выступает либо некий числовой идентификатор либо строка. Однако работа с таким типом ключей подвержена проблемам:
1. Реестр возможных (допустимых) ключей нужно где-то вести, иначе будут проблемы с хардкодом значений ключей во всему коду и собрать целостную картину для исключения коллизий будет проблематично, но реестр тоже может не спасти от лени разработчиков
1. Из-за полной свободы с ключами невозможно эффективно проводить рефакторинг
1. При получении значений необходимо проводить проверки наличия значения, проверять тип значения а потом приводить значение к нужному типу.

Т.е. типичный код выглядит так:
```csharp
// Установим значение
dic.Set(Codes.SomeCode1, new TValue(...));

// Получим значение ожидаемого типа
if (dic.TryGet(Codes.SomeCode1, out var data) && data is TValue typedData)
{
    // TODO: Данные есть
} else
{
    // TODO: Данных нет или они не того типа
}
```
Громоздко и ненадежно. 

Но если в качестве ключа использовать тип значения т.е. должно соблюдаться условие `TValue is TKey == true` то все становится проще:
```csharp
// Установим значение
dic.Set<TValue>(new TValue(...));

// Получим значение ожидаемого типа
var typedData = dic.TryGet<TValue>();
```

При этом реализация и сигнатура методов Set/TryGet проста и надежна, для удобства и сохранения концепций .NET сделаем 2 основных интерфейса:
```csharp
public interface IReadOnlyTypedContainer
{
	/// <summary>
	/// Получить значение указанного типа, если нет значения - вернуть nodata.
	/// </summary>
    TData TryGet<TData>(TData nodata = default);
}

public interface ITypedContainer : IReadOnlyTypedContainer
{
	/// <summary>
	/// Установить значение указанного типа, если передать null, то значение будет удалено
	/// </summary>
    void Set<TData>(TData data);
}
```
Все, это - основа.
