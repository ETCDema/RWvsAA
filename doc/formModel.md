# Form model

Итак, мы определились с тем, что именно FormModel отправляется в шаблон для генерации HTML и потом используется для раскладки данных из запроса. Теперь посмотрим что у нас изменилось в схеме [приведенной ранее](#doc:start).

![Form Model](/img/form-model.min.svg)

FormModel мы связываем с моделью данных и передаем в шаблон для генерации HTML, при этом у нас одна FormModel на все наши модели данных и основной шаблон нам нужен один. Далее для каждого типа свойства мы создадим свои шаблоны, в самом начале нам точно потребуются шаблоны ввода/отображения текста, числа, даты и Enum, потом добавятся еще узкоспециализированные шаблоны какой-либо сложной структуры, например для ввода/отображения адреса или кодов аналитики.

Логично предположить что в эти вложенные шаблоны саму FormModel мы передавать не будем, но нам нужен аналог уже для отдельного свойства модели данных и назовем эту сущность Element. По сути это тоже FromModel, но самостоятельно существовать не может и отвечает за конкретное свойство модели данных.

При раскладке данных нам нужен источник этих самых данных и можно совершенно спокойно использовать например стандартную IFromCollection, которую мы передаем в FormModel а внутри уже передается в Element для обработки конкретных значений.

FormModel и Element будут у нас контейнерами информации для генерации HTML, раскладки и валидации данных, по сути заменят нам ModelMetadata и может показаться, что мы будем строить God-like объекты, но это не так. Эти объекты будут построены на очень простом, но, как показала практика, очень эффективном подходе.

## Основа для FormModel и Elements

На идею этого подхода натолкнули 2 вещи:
1. Статья про разработку игры, где вместо наследования использовалось агрегация
1. Организация контекста в OWIN

Там по сути была описана работа с некими `IDictionary<TKey, object>`, где в качестве TKey выступает либо некий числовой идентификатор либо строка. Однако работа с таким типом ключей подвержена проблемам:
1. Реестр возможных (допустимых) ключей нужно где-то вести, иначе будут проблемы с хардкодом значений ключей во всему коду и собрать целостную картину для исключения коллизий будет проблематично, но реестр тоже может не спасти от лени разработчиков
1. Из-за полной свободы с ключами невозможно эффективно проводить рефакторинг
1. При получении значений необходимо проводить проверки наличия значения, проверять тип значения а потом приводить значение к нужному типу.

Т.е. типичный код выглядит так:
```csharp
// Установим значение
dic.Set(Codes.SomeCode1, new TValue(...));

// Получим значение ожидаемого типа
if (dic.TryGet(Codes.SomeCode1, out var data) && data is TValue typedData)
{
    // TODO: Данные есть
} else
{
    // TODO: Данных нет или они не того типа
}
```
Громоздко и ненадежно. 

Но если в качестве ключа использовать тип значения т.е. должно соблюдаться условие `TValue is TKey == true` то все становится проще:
```csharp
// Установим значение
dic.Set<TValue>(new TValue(...));

// Получим значение ожидаемого типа
var typedData = dic.TryGet<TValue>();
```

При этом реализация и сигнатура методов Set/TryGet проста и надежна, для удобства и сохранения концепций .NET сделаем 2 основных интерфейса:
```csharp
public interface IReadOnlyTypedContainer
{
	/// <summary>
	/// Получить значение указанного типа, если нет значения - вернуть nodata.
	/// </summary>
    TData TryGet<TData>(TData nodata = default);
}

public interface ITypedContainer : IReadOnlyTypedContainer
{
	/// <summary>
	/// Установить значение указанного типа, если передать null, то значение будет удалено
	/// </summary>
    void Set<TData>(TData data);
}
```
Все, это - основа.

## Основной класс - FormModel

Реализацию начнем с контроллера, где определим как же мы хотим работать с нашей моделью формы:
```csharp
/// <summary>
/// Отображение данных
/// </summary>
public IActionResult Default()
{
	var frm    = new FormModel /*TODO: Настройка модели формы*/;

	frm.Model  = _getData();    // Получаем данные для отображения и передаем в модель отображения

	return View(frm);           // Все, далее только генерация HTML шаблонами
}
```
В случае изменения данных код немного усложняется:
```csharp
/// <summary>
/// Отображение и изменение данных
/// </summary>
/// <param name="data">Данные запроса</param>
public IActionResult Default(IFormCollection data)
{
	var frm    = new FormModel /*TODO: Настройка модели формы*/;

	frm.Model  = _getData();    // Получаем данные для отображения и передаем в модель отображения
	if (frm.Bind(data))         // Раскладка и проверка данных из запроса
	{
		// TODO: Bind Ok
	}

	return View(frm);           // Все, далее только генерация HTML шаблонами
}
```
В итоге нам в классе модели формы нужно два свойства и один метод:
* Model - непосредственно модель данных, с которой работаем
* Elements - коллекция элементов
* Метод Bind, в котором будет происходить процесс раскладки и проверки данных. 

Пока все выглядит просто. Может вся сложность будет в классе элемента модели формы? Давайте посмотрим что нам нужно там:
* ID - идентификатор элемента для генерации результата и раскладки данных из запроса
* Name - отображаемое имя элемента, требуется на многих этапах для создания сообщений пользователям
* GetFx - функция для получения значения из модели данных
* UIHint - имя шаблона, если он отличен от типа значения, возвращаемого GetFx
* Признак ReadOnly, который будет запрещать раскладку данных и блокировать генерацию полей ввода в шаблоне
* Настройка отображения элемента в рамках модели формы
* Возможно потребуются данные для шаблона
* Настройка генерации JSON
* SetFx - функция для изменения значения модели данных по данным из запроса
* Validate - функция проверки значения из запроса перед или после вызова SetFx
* Error - проблема с элементом

Вот тут набор уже большой, но мы сделаем наш элемент через ITypedContainer, а для этого определим минимум необходимого в самом элементе и какие части будем помещать в ITypedContainer часть. Что точно нужно везде и имеет смысл создать в самом классе Element - свойства ID, Name, GetFx, ReadOnly и, возможно, Error. Остальное разбивается на 2 большие части: данные для отображения (UIHint, настройки элемента и данные для шаблона) и данные для раскладки и проверки значений из запроса (SetFx, Validate). Особняком стоит настройка генерации JSON, но это дополнительная тема и пока ее можно пропустить.